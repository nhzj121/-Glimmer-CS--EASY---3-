# 2024090908012-但家利-CS-03 #
## C语言内存模型 ##
### 程序代码区 ###
<p>具体含义：存储程序二进制指令的内存区域</p>  
<p>应用场景：存储机器代码，重定位  </p>
<p>调用方式：直接调用。 间接调用（通过指针实现。</p>
<h3> 常量区: </h3>
<p>具体含义：存储程序中的常量，如字符常量，数字常量，const修饰的全局变量和字符串常量</p>
<p>应用场景：存储常量</p>
<p>调用方式：直接访问它们的定义名称来调用的</p>
<h3> 全局数据区：</h3>
<p>具体含义：存储已经初始化的全局变量和静态变量</p>
<p>应用场景：存储全局变量，存储静态变量</p>
<p>调用方式：直接访问；在函数内部声明；如果需要在不同的文件中访问同一个全局变量，需要在其他文件中使用 extern 关键字来声明它。</p>
<h3>堆区：</h3>
<p>具体含义：用来存放进程运行中被动态分配的内存段，用于存储程序运行时创建的对象、数据结构和动态分配的内存块</p>
<p>应用场景：优先队列，排序算法，图算法</p>
<p>调用方式：</p> 
<p>`malloc(size_t size)`：分配指定大小的内存块，返回指向它的指针。</p>
<p>`calloc(size_t num, size_t size)`：分配内存块，并初始化为零。</p>
<p>`realloc(void *ptr, size_t new_size)`：更改先前分配的内存块的大小。</p>
<p>`free(void *ptr)`：释放先前分配的内存块。</p>
<h3>动态链接库：</h3>
<p>具体含义：是一个可以被其它应用程序共享的程序模块，其中封装了一些可以被共享的例程和资源</p>
<p>应用场景：多个不同主程序需使用相同程序的函数时</p>
<p>调用方式：静态调用，动态调用</p>
<h3>栈区：</h3>
<p>具体含义：存放局部变量 函数参数 返回值</p>
<p>应用场景：回溯算法，撤销操作，深度优先算法</p>
<p>调用方式：创建一个空栈，通常使用特定的数据结构来实现，如数组或链表。</p>

## 导学问题
1. 指程序在运行过程中，尝试向栈（Stack）中写入的数据超过了栈的内存限制。
2. 栈由操作系统自动分配和释放而堆需要程序员手动管理； 栈内存空间相对较小而堆的内存空间相对较大； 栈主要用于存储函数调用时的参数、局部变量和返回地址等，而堆用于存储动态分配的数据，如动态数组、链表、树等数据结构； 栈不需要使用分配函数而堆需要使用分配函数
3. <p>只读：程序代码区，常量区</p>
   <p>堆区，栈区，全局数据区</p>
   <p>动态链接库中的代码和只读数据是只读的，但其中的数据段可以包含全局变量，是可读写的</p>
4. `malloc()`: `void* malloc(size_t size);` 其中`void`表返回值类型，`size`表参数名，`size_t`是参数类型  `free()`: `void free(void* ptr)`其中`void`表返回值类型，`void* ptr`表要指向释放内存块的通用指针`ptr`是参数名称； 堆区
5. 方便对不同类型的数据等的管理，提高内存使用效率；使不同类型数据等分区，有利于提高程序的可移植性；便于防止内存碎片化，优化内存分配

## 内存模型的应用
`constValue``constString`:存储在常量区。首先，两者有`const`前缀，其次是全局变量且均被初始化，所以可以判断，两者是不允许被更改的，应当存储在常量区。
